Understanding Compiler

# https://www.recompiled.dev/blog/alias-analysis/

컴파일한다는것은 리액트를 언어의 컨셉으로까지 보는것이아닌가 ?

_[Forget](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-optimizing-compiler) was the code name for the React Compiler._

The catch is that React can sometimes be _too_ reactive: it can re-render too much.

rules of react를 활용하여 react compiler는 코드를 최적화한다.

HIR
// AST -> (lowering) -> HIR -> (analysis) -> Reactive Scopes -> (codegen) -> AST

# [react compiler(react docs)](https://react.dev/learn/react-compiler)

- It is a build-time only tool that automatically optimizes your React app. It works with plain JavaScript, and understands the [Rules of React](https://react.dev/reference/rules), so you don’t need to rewrite any code to use it.

- useMemoCache

# [React Without Memo](https://www.youtube.com/watch?v=lGEMwh32soc)

2021년 리액트 컨퍼런스에서 공개된 이 컴파일러는 React.memo 또는 React.useCallback의 필요성을 감지하여 컴포넌트 리렌더링 성능을 향상시킨다. 컴파일러는 이러한 구조와 유사한 동작을 하는 코드를 삽입하여 리액트 애플리케이션의 성능을 최적화한다.
상태값이 의미 있게 변경될 때만 애플리케이션이 다시 렌더링되도록 보장한다.
`useMemo`와 `useCallback`은 성능을 최적화하는 훌륭한 도구이지만 코드에 복잡성을 추가하고 올바르게 사용하기 어려울 수 있습니다. 의존성 배열을 올바르게 지정하지 않으면 혼란스러운 버그와 성능 문제가 발생할 수 있습니다. 또한 이러한 Hook을 사용하면 코드를 읽고 이해하기 어려울 수 있습니다.

리액트 Forget은 메모화 프로세스를 자동화하여 이러한 문제를 해결하는 것을 목표로 합니다. 새로운 컴파일러를 사용하면 개발자가 수동으로 `useMemo`나 `useCallback`을 사용할 필요가 없습니다. 대신 컴파일러가 메모화가 필요한 시점을 자동으로 판단하여 적용하므로 개발자의 정신적 부담이 줄어들고 코드를 읽고 이해하기 쉬워집니다.

React makes it easier to build great user experiences.
React Forget

React의 핵심 아이디어는 현재 상태의 함수로 UI를 정의하는 것이다.  이는 개발자가 애플리케이션(이하 앱)의 각 상태에 대한 UI를 선언적으로 정의하고, 상태 변경 시 React가 자동으로 UI를 업데이트하는 방식을 의미합니다.

UI is a function of a state.

https://developers.kakaomobility.com/docs/techblogs/react-compiler/

# [Rules of React](https://react.dev/reference/rules)

Compiler REPL: [https://github.com/jherr/compiler-repl](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbGh4aHd3aVBTdFBKRG9MUENjc2hRVTlhLVNld3xBQ3Jtc0trd2NWWjFLTlZTRkIwaG9sQm9aeXhndFRmZjdJRWhOdVB2VDVKNTZuOG9URDNiSmtsbkwzS0lJbV8xdEdqNVk0ZDZ2NzdaU1RHWDBCLUdVTlJZMHJ5ZVJrQUVDSC1nOGw3dGJfWWp1eWhPbzJFVWIzMA&q=https%3A%2F%2Fgithub.com%2Fjherr%2Fcompiler-repl&v=PYHBHK37xlE) Meta REPL: [https://playground.react.dev/](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbWtpYktZaE9haTk4cnNndF9WMWR6QWpzLXRJUXxBQ3Jtc0trSFdvSHM2dEowcHBDRzJwOE14QzBsdjFuUXlMVkp3eTRYS0J6WlNqcnROdms3SkJJaDVhd0xSZ2hnb0dqVzViZXFlZ1RaME9zTzFKa3lSUXZNYXZ5U0s3SlItVzlldG1JcGczSERWR2J4cUI5Q19XVQ&q=https%3A%2F%2Fplayground.react.dev%2F&v=PYHBHK37xlE)

https://github.com/facebook/react/pull/29061

- the complier uses its knowledge of javascript and the rules of react to automatically memoize values within your components and hooks so if it detects any breakages of the rules it will automatically skip over them and continue to compile the rest of your app.
- The core idea of React is that developers define their UI as a function of the current state.
- The mental model is that React will re-render whenever the application state changes.
- We believe this simple mental model and keeping close to JavaScript semantics is an important principle in React’s programming model.
- The catch is that React can sometimes be _too_ reactive: it can re-render too much. For example, in JavaScript we don’t have cheap ways to compare if two objects or arrays are equivalent (having the same keys and values), so creating a new object or array on each render may cause React to do more work than it strictly needs to. This means developers have to explicitly memoize components so as to not over-react to changes.

# [What's next for the React Compiler?](https://www.youtube.com/watch?v=qd5yk2gxbtg)

- our recommendation for library authors to independently complie and test thier libraries and then ship the compiled code to npm so that applications can just start using the compiled code

# [React Labs: What We've Been Working On - March 2023](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-optimizing-compiler)

- Our goal with React Forget is to ensure that React apps have just the right amount of reactivity by default: that apps re-render only when state values _meaningfully_ change.
- One way to think about this is that React currently re-renders when object identity changes. With Forget, React re-renders when the semantic value changes — but without incurring the runtime cost of deep comparisons.
-

- [i tried react compiler](https://www.developerway.com/posts/i-tried-react-compiler)
- [react compiler: deep dive](https://www.youtube.com/watch?v=0ckOUBiuxVY&t=9309s)
-

The idea of React Compiler is to allow developers to use React's familiar declarative, component-based programming model, while ensuring that apps are fast by default. Concretely we seek to achieve the following goals:

- Bound the amount of re-rendering that happens on updates to ensure that apps have predictably fast performance by default.
- Keep startup time neutral with pre-React Compiler performance. Notably, this means holding code size increases and memoization overhead low enough to not impact startup.
- Retain React's familiar declarative, component-oriented programming model. Ie, the solution should not fundamentally change how developers think about writing React, and should generally _remove_ concepts (the need to use React.memo(), useMemo(), and useCallback()) rather than introduce new concepts.
- "Just work" on idiomatic React code that follows React's rules (pure render functions, the rules of hooks, etc).
- Support typical debugging and profiling tools and workflows.
- Be predictable and understandable enough by React developers — i.e. developers should be able to quickly develop a rough intuition of how React Compiler works.
- Not require explicit annotations (types or otherwise) for typical product code. We may provide features that allow developers to opt-in to using type information to enable additional optimizations, but the compiler should work well without type information or other annotations.

## Non-Goals

The following are explicitly _not_ goals for React Compiler:

- Provide perfectly optimal re-rendering with zero unnecessary recomputation. This is a non-goal for several reasons:
  - The runtime overhead of the extra tracking involved can outweight the cost of recomputation in many cases.
  - In cases with conditional dependencies it may not be possible to avoid recomputing some/all instructions.
  - The amount of code may regress startup times, which would conflict with our goal of neutral startup performance.
- Support code that violates React's rules. React's rules exist to help developers build robust, scalable applications and form a contract that allows us to continue improving React without breaking applications. React Compiler depends on these rules to safely transform code, and violations of rules will therefore break React Compiler's optimizations.
- Support legacy React features. Notably we will not support class components due to their inherent mutable state being shared across multiple methods with complex lifetimes and data flow.
- Support 100% of the JavaScript language. In particular, we will not support rarely used features and/or features which are known to be unsafe or which cannot be modeled soundly. For example, nested classes that capture values from their closure are difficult to model accurately because of mutability, and `eval()` is unsafe. We aim to support the vast majority of JavaScript code (and the TypeScript and Flow dialects)

## Design Principles

Many aspects of the design follow naturally from the above goals:

- The compiler output must be high-level code that retains not just the semantics of the input but also is expressed using similar constructs to the input. For example, rather than convert logical expressions (`a ?? b`) into an `if` statement, we retain the high-level form of the logical expression. Rather than convert all looping constructs to a single form, we retain the original form of the loop. This follows from our goals:
  - High-level code is more compact, and helps reduce the impact of compilation on application size.
  - High-level constructs that match what the developer wrote are easier to debug.
- From the above, it then follows that the compiler's internal representation must also be high-level enough to be able to output the original high-level constructs. The internal representation is what we call a High-level Intermediate Representation (HIR) — a name borrowed from Rust Compiler. However, React Compiler's HIR is perhaps even more suited to this name, as it retains high-level information (distinguishing if vs logical vs ternary, or for vs while vs for..of) but also represents code as a control-flow graph with no nesting.

## Architecture

- **Babel Plugin**: Determines which functions in a file should be compiled, based on the plugin options and any local opt-in/opt-out directives. For each component or hook to be compiled, the plugin calls the compiler, passing in the original function and getting back a new AST node which will replace the original.
- **Lowering** (BuildHIR): The first step of the compiler is to convert the Babel AST into React Compiler's primary intermediate representation, HIR (High-level Intermediate Representation). This phase is primarily based on the AST itself, but currently leans on Babel to resolve identifiers. The HIR preserves the precise order-of-evaluation semantics of JavaScript, resolves break/continue to their jump points, etc. The resulting HIR forms a control-flow graph of basic blocks, each of which contains zero or more consecutive instructions followed by a terminal. The basic blocks are stored in reverse postorder, such that forward iteration of the blocks allows predecessors to be visited before successors _unless_ there is a "back edge" (ie a loop).
- **SSA Conversion** (EnterSSA): The HIR is converted to HIR form, such that all Identifiers in the HIR are updated to an SSA-based identifier.
- Validation: We run various validation passes to check that the input is valid React, ie that it does not break the rules. This includes looking for conditional hook calls, unconditional setState calls, etc.
- **Optimization**: Various passes such as dead code elimination and constant propagation can generally improve performance and reduce the amount of instructions to be optimized later.
- **Type Inference** (InferTypes): We run a conservative type inference pass to identify certain key types of data that may appear in the program that are relevant for further analysis, such as which values are hooks, primitives, etc.
- **Inferring Reactive Scopes**: Several passes are involved in determining groups of values that are created/mutated together and the set of instructions involved in creating/mutating those values. We call these groups "reactive scopes", and each can have one or more declarations (or occasionally a reassignment).
- **Constructing/Optimizing Reactive Scopes**: Once the compiler determines the set of reactive scopes, it then transforms the program to make these scopes explicit in the HIR. The code is later converted to a ReactiveFunction, which is a hybrid of the HIR and an AST. Scopes are further pruned and transformed. For example, the compiler cannot make hook calls conditional, so any reactive scopes that contain a hook call must be pruned. If two consecutive scopes will always invalidate together, we attempt to merge them to reduce overhead, etc.
- **Codegen**: Finally, the ReactiveFunction hybrid HIR/AST is converted back to a raw Babel AST node, and returned to the Babel plugin.
- **Babel Plugin**: The Babel plugin replaces the original node with the new version.

The ESLint plugin works similarly. For now, it effectively invokes the Babel plugin on the code and reports back a subset of the errors. The compiler can report a variety of errors, including that the code is simply invalid JavaScript, but the ESLint plugin filters to only show the React-specific errors.
