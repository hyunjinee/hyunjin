[{"title":"1년간의 이야기","date":"2024-12-31T00:00:00.000Z","tags":["회고"],"summary":null,"images":["/images/hyunjin/digital-beauty.jpeg"],"layout":"PostBanner","type":"Blog","readingTime":{"text":"15 min read","minutes":14.905,"time":894300,"words":2981},"slug":"1년간의 이야기","path":"blog/1년간의 이야기","filePath":"blog/1년간의 이야기.mdx","toc":[{"value":"입사 (2023년 9월)","url":"#입사-2023년-9월","depth":1},{"value":"PROVE IT (2023년 10,11월)","url":"#prove-it-2023년-1011월","depth":1},{"value":"2023년 12월, 2024년 1월","url":"#2023년-12월-2024년-1월","depth":1},{"value":"프론트엔드 엔지니어가 하고싶어요 2024년 2,3월","url":"#프론트엔드-엔지니어가-하고싶어요-2024년-23월","depth":1},{"value":"Goodbye 2024년 4월","url":"#goodbye-2024년-4월","depth":1},{"value":"2024년 5,6,7월","url":"#2024년-567월","depth":1},{"value":"카카오 엔터테인먼트 Frontend Engineer 2024년 8,9월","url":"#카카오-엔터테인먼트-frontend-engineer-2024년-89월","depth":1},{"value":"Step Forward","url":"#step-forward","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"1년간의 이야기","datePublished":"2024-12-31T00:00:00.000Z","dateModified":"2024-12-31T00:00:00.000Z","description":null,"image":"/images/hyunjin/digital-beauty.jpeg","url":"https://hyunjinlee.com/blog/1년간의 이야기"}},{"title":"낙관적 업데이트 순서제어","date":"2024-02-13T00:00:00.000Z","tags":["react-query"],"lastmod":"2024-02-13T00:00:00.000Z","draft":false,"summary":"react-query에서 낙관적 업데이트를 구현할 때 잘못 생각하고 있었던 부분을 바로잡고, 낙관적 업데이트를 구현하면서 발생할 수 있는 순서문제를 제어하는 방법에 대한 글이다.","images":["/images/thumbnails/낙관적-업데이트-순서제어.png"],"authors":["default"],"layout":"PostBanner","bibliography":"references-data.bib","type":"Blog","readingTime":{"text":"10 min read","minutes":9.485,"time":569100,"words":1897},"slug":"낙관적 업데이트 순서제어","path":"blog/낙관적 업데이트 순서제어","filePath":"blog/낙관적 업데이트 순서제어.mdx","toc":[{"value":"Reference","url":"#reference-1","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"낙관적 업데이트 순서제어","datePublished":"2024-02-13T00:00:00.000Z","dateModified":"2024-02-13T00:00:00.000Z","description":"react-query에서 낙관적 업데이트를 구현할 때 잘못 생각하고 있었던 부분을 바로잡고, 낙관적 업데이트를 구현하면서 발생할 수 있는 순서문제를 제어하는 방법에 대한 글이다.","image":"/images/thumbnails/낙관적-업데이트-순서제어.png","url":"https://hyunjinlee.com/blog/낙관적 업데이트 순서제어"}},{"title":"리액트 렌더링에 대한 이해","date":"2023-03-04T00:00:00.000Z","tags":["react"],"draft":false,"summary":"이 글에서는 리액트의 렌더링을 렌더 단계와 커밋 단계로 구분하여 전체적인 렌더링 프로세스에 대해 이해해봅니다.","images":["/images/thumbnails/react.png"],"layout":"PostBanner","type":"Blog","readingTime":{"text":"10 min read","minutes":9.195,"time":551700,"words":1839},"slug":"리액트 렌더링에 대한 이해","path":"blog/리액트 렌더링에 대한 이해","filePath":"blog/리액트 렌더링에 대한 이해.mdx","toc":[{"value":"Rendering in React","url":"#rendering-in-react","depth":2},{"value":"React Element","url":"#react-element","depth":3},{"value":"Virtual DOM","url":"#virtual-dom","depth":3},{"value":"Dirty Checking","url":"#dirty-checking","depth":3},{"value":"Render Phase와 Commit Phase","url":"#render-phase와-commit-phase","depth":3},{"value":"Reference","url":"#reference","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"리액트 렌더링에 대한 이해","datePublished":"2023-03-04T00:00:00.000Z","dateModified":"2023-03-04T00:00:00.000Z","description":"이 글에서는 리액트의 렌더링을 렌더 단계와 커밋 단계로 구분하여 전체적인 렌더링 프로세스에 대해 이해해봅니다.","image":"/images/thumbnails/react.png","url":"https://hyunjinlee.com/blog/리액트 렌더링에 대한 이해"}},{"title":"왜 setState는 비동기적으로 동작하는가?","date":"2023-01-15T00:00:00.000Z","tags":["react"],"draft":false,"summary":"이 글에서는 setState의 동작에 대해서 알아봅니다.","images":["/images/thumbnails/react.png"],"layout":"PostBanner","type":"Blog","readingTime":{"text":"24 min read","minutes":23.415,"time":1404900,"words":4683},"slug":"왜 setState는 비동기적으로 동작하는가","path":"blog/왜 setState는 비동기적으로 동작하는가","filePath":"blog/왜 setState는 비동기적으로 동작하는가.mdx","toc":[{"value":"setState의 동작","url":"#setstate의-동작","depth":2},{"value":"Why is setState asynchronous? 이슈 번역","url":"#why-is-setstate-asynchronous-이슈-번역","depth":2},{"value":"1. 비동기 렌더링에는 비동기 setState가 필요합니다.","url":"#1-비동기-렌더링에는-비동기-setstate가-필요합니다","depth":3},{"value":"2. 어떤 상태가 렌더링되었는지 알기 위해서는 비동기 setState가 필요합니다.","url":"#2-어떤-상태가-렌더링되었는지-알기-위해서는-비동기-setstate가-필요합니다","depth":3},{"value":"1. 내부 일관성 보장(Guaranteeing Internal Consistency)","url":"#1-내부-일관성-보장guaranteeing-internal-consistency","depth":3},{"value":"동시 업데이트 활성화(Enabling Concurrent Updates)","url":"#동시-업데이트-활성화enabling-concurrent-updates","depth":3},{"value":"왜 setState는 비동기적으로 작동하는가?","url":"#왜-setstate는-비동기적으로-작동하는가","depth":2},{"value":"setState 코드 보기","url":"#setstate-코드-보기","depth":2},{"value":"결론","url":"#결론","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"왜 setState는 비동기적으로 동작하는가?","datePublished":"2023-01-15T00:00:00.000Z","dateModified":"2023-01-15T00:00:00.000Z","description":"이 글에서는 setState의 동작에 대해서 알아봅니다.","image":"/images/thumbnails/react.png","url":"https://hyunjinlee.com/blog/왜 setState는 비동기적으로 동작하는가"}},{"title":"Flux","date":"2022-12-20T00:00:00.000Z","tags":[],"draft":false,"summary":"이 글에서는 Flux 아키텍처가 무엇인지 알아봅니다.","images":["https://velog.velcdn.com/images/hyunjine/post/a701dad7-a978-4e0b-90b2-0223fa32143e/image.png"],"layout":"PostBanner","type":"Blog","readingTime":{"text":"15 min read","minutes":14.77,"time":886200,"words":2954},"slug":"flux","path":"blog/flux","filePath":"blog/flux.mdx","toc":[{"value":"MVC의 문제점","url":"#mvc의-문제점","depth":2},{"value":"Flux","url":"#flux","depth":2},{"value":"생각","url":"#생각","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Flux","datePublished":"2022-12-20T00:00:00.000Z","dateModified":"2022-12-20T00:00:00.000Z","description":"이 글에서는 Flux 아키텍처가 무엇인지 알아봅니다.","image":"https://velog.velcdn.com/images/hyunjine/post/a701dad7-a978-4e0b-90b2-0223fa32143e/image.png","url":"https://hyunjinlee.com/blog/flux"}}]