{"version":3,"sources":["../../src/query.ts"],"sourcesContent":["import { QueryCache } from './queryCache';\nimport { Removable } from './removable';\nimport { DefaultError, FetchStatus, InitialDataFunction, QueryKey, QueryOptions, QueryStatus } from './types';\n\ninterface QueryConfig<TQueryFnData, TError, TData, TQueryKey extends QueryKey = QueryKey> {\n  cache: QueryCache;\n  queryKey: TQueryKey;\n  queryHash: string;\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined;\n  dataUpdateCount: number;\n  dataUpdatedAt: number;\n  error: TError | null;\n  errorUpdateCount: number;\n  errorUpdatedAt: number;\n  fetchFailureCount: number;\n  fetchFailureReason: TError | null;\n  fetchMeta: FetchMeta | null;\n  isInvalidated: boolean;\n  status: QueryStatus;\n  fetchStatus: FetchStatus;\n}\n\nexport type FetchDirection = 'forward' | 'backward';\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection };\n}\n\ninterface FailedAction<TError> {\n  type: 'failed';\n  failureCount: number;\n  error: TError;\n}\n\ninterface FetchAction {\n  type: 'fetch';\n  meta?: FetchMeta;\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined;\n  type: 'success';\n  dataUpdatedAt?: number;\n  manual?: boolean;\n}\n\ninterface ErrorAction<TError> {\n  type: 'error';\n  error: TError;\n}\n\ninterface InvalidateAction {\n  type: 'invalidate';\n}\n\ninterface PauseAction {\n  type: 'pause';\n}\n\ninterface ContinueAction {\n  type: 'continue';\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState';\n  state: Partial<QueryState<TData, TError>>;\n  setStateOptions?: SetStateOptions;\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>;\n\nexport interface SetStateOptions {\n  meta?: any;\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey;\n  queryHash: string;\n\n  #abortSignalConsumed: boolean;\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super();\n\n    this.#abortSignalConsumed = false;\n    this.queryHash = config.queryHash;\n  }\n\n  get meta() {}\n\n  get promise() {}\n}\n\nexport function fetchState<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {}\n\nfunction getDefaultState<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData;\n\n  const hasData = data !== undefined;\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0;\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  };\n}\n"],"mappings":";AACA,SAAS,iBAAiB;AAuFnB,IAAM,QAAN,cAKG,UAAU;AAAA,EAIlB;AAAA,EAEA,YAAY,QAA6D;AACvE,UAAM;AAEN,SAAK,uBAAuB;AAC5B,SAAK,YAAY,OAAO;AAAA,EAC1B;AAAA,EAEA,IAAI,OAAO;AAAA,EAAC;AAAA,EAEZ,IAAI,UAAU;AAAA,EAAC;AACjB;AAEO,SAAS,WACd,MACA,SACA;AAAC;","names":[]}